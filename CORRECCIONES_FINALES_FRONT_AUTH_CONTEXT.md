# CORRECCIONES FINALES FRONT AUTH CONTEXT

## üìã Resumen del Estado Actual

El `authcontext.js` del frontend ha implementado **correctamente la mayor√≠a de las correcciones** necesarias para el flujo de sesi√≥n de 30 d√≠as. Solo quedan **3 problemas menores** que requieren ajustes finales.

---

## ‚úÖ **Correcciones Ya Implementadas Correctamente**

### 1. **Silent Login Corregido** ‚úÖ
```javascript
// ‚úÖ CORRECTO - GET con query parameter
const response = await fetch(
  `${getBackendUrl()}/auth/google/silent?email=${encodeURIComponent(email)}`,
  { method: 'GET', credentials: 'include' }
);
```

### 2. **Migraci√≥n a useRef** ‚úÖ
```javascript
// ‚úÖ CORRECTO - Variables de control persistentes
const sessionCheckPromiseRef = useRef(null);
const lastSessionCheckRef = useRef(0);
const tokenRefreshPromiseRef = useRef(null);
const lastTokenRefreshRef = useRef(0);
```

### 3. **Verificaci√≥n JWT Expiration** ‚úÖ
```javascript
// ‚úÖ CORRECTO - Solo usa exp del JWT
const isAccessTokenExpired = () => {
  if (!accessToken) return true;
  try {
    const payload = JSON.parse(atob(accessToken.split('.')[1]));
    return Date.now() >= payload.exp * 1000;
  } catch {
    return true;
  }
};
```

### 4. **Eliminaci√≥n de getNewAccessToken** ‚úÖ
- ‚úÖ Funci√≥n eliminada
- ‚úÖ No hay llamadas a `/auth/token`

### 5. **Reintento Autom√°tico en 401** ‚úÖ
```javascript
// ‚úÖ CORRECTO - Renovaci√≥n y reintento
if (response.status === 401) {
  try {
    await refreshAccessToken();
    // ... reintento con nuevo token
  } catch (e) {
    throw new Error('Token de autenticaci√≥n inv√°lido o expirado');
  }
}
```

---

## ‚ö†Ô∏è **Correcciones Finales Requeridas**

### 1. **Eliminar Completamente token_expiry**

**‚ùå Problema encontrado:**
```javascript
// L√≠neas 345-347 en getAuthToken()
if (userData.token_expiry) {
  localStorage.setItem('token_expiry', userData.token_expiry);
}
```

**‚úÖ Correcci√≥n:**
```javascript
// ELIMINAR estas l√≠neas completamente
// if (userData.token_expiry) {
//   localStorage.setItem('token_expiry', userData.token_expiry);
// }
```

**üìù Acci√≥n:** Buscar y eliminar **todas** las referencias a `token_expiry` en el archivo.

---

### 2. **Corregir initializeTokens()**

**‚ùå Problema actual:**
```javascript
const initializeTokens = () => {
  const savedToken = localStorage.getItem('access_token');
  const savedRefresh = localStorage.getItem('refresh_token');
  
  if (savedRefresh) {
    setRefreshToken(savedRefresh);
  }

  if (savedToken) {
    // ‚ùå PROBLEMA: Llama isAccessTokenExpired() antes de setAccessToken
    if (!isAccessTokenExpired()) { // accessToken es null aqu√≠
      console.log('üîë Token v√°lido encontrado en localStorage');
      setAccessToken(savedToken);
      return true;
    } else {
      console.log('‚è∞ Token expirado en localStorage, limpiando...');
      localStorage.removeItem('access_token');
    }
  }
  
  return false;
};
```

**‚úÖ Correcci√≥n:**
```javascript
const initializeTokens = () => {
  const savedToken = localStorage.getItem('access_token');
  const savedRefresh = localStorage.getItem('refresh_token');
  
  if (savedRefresh) {
    setRefreshToken(savedRefresh);
  }

  if (savedToken) {
    // ‚úÖ CORRECTO: Setear token primero, luego verificar
    setAccessToken(savedToken);
    
    // Verificar expiraci√≥n despu√©s de setear el token
    if (isAccessTokenExpired()) {
      console.log('‚è∞ Token expirado en localStorage, limpiando...');
      setAccessToken(null);
      localStorage.removeItem('access_token');
      return false;
    }
    
    console.log('üîë Token v√°lido encontrado en localStorage');
    return true;
  } else {
    console.log('‚ùå No hay tokens guardados en localStorage');
  }
  
  return false;
};
```

---

### 3. **Optimizar getAuthToken()**

**‚ùå Problema actual:**
```javascript
// L√≥gica confusa con m√∫ltiples intentos y fallbacks
const getAuthToken = async () => {
  // ... c√≥digo complejo con m√∫ltiples paths
};
```

**‚úÖ Correcci√≥n simplificada:**
```javascript
const getAuthToken = async () => {
  // 1. Si tenemos un token v√°lido, usarlo directamente
  if (accessToken && !isAccessTokenExpired()) {
    return accessToken;
  }
  
  // 2. Evitar llamadas simult√°neas
  if (tokenRefreshPromiseRef.current) {
    return await tokenRefreshPromiseRef.current;
  }
  
  // 3. Verificar cooldown
  const now = Date.now();
  if (now - lastTokenRefreshRef.current < TOKEN_REFRESH_COOLDOWN) {
    return accessToken || null;
  }
  
  lastTokenRefreshRef.current = now;
  
  tokenRefreshPromiseRef.current = (async () => {
    try {
      // Prioridad 1: Renovar con refresh_token
      if (refreshToken || localStorage.getItem('refresh_token')) {
        return await refreshAccessToken();
      }
      
      // Prioridad 2: Obtener token fresco desde /auth/session
      const response = await fetch(`${getBackendUrl()}/auth/session`, {
        credentials: 'include',
        method: 'GET',
        headers: { 'Content-Type': 'application/json' }
      });
      
      if (response.ok) {
        const data = await response.json();
        if (data.access_token) {
          setAccessToken(data.access_token);
          localStorage.setItem('access_token', data.access_token);
          return data.access_token;
        }
      }
      
      return null;
    } finally {
      tokenRefreshPromiseRef.current = null;
    }
  })();
  
  return await tokenRefreshPromiseRef.current;
};
```

---

## üîç **B√∫squeda y Reemplazo Requerida**

### Eliminar todas las referencias a token_expiry:

```bash
# Buscar estas l√≠neas y ELIMINARLAS:
- "token_expiry"
- "setTokenExpiry"
- "localStorage.setItem('token_expiry'"
- "localStorage.getItem('token_expiry'"
- "userData.token_expiry"
```

### Verificar que no queden referencias:
```javascript
// ‚ùå ELIMINAR si aparecen:
if (userData.token_expiry) { ... }
setTokenExpiry(userData.token_expiry);
localStorage.setItem('token_expiry', userData.token_expiry);
localStorage.getItem('token_expiry');
```

---

## üìã **Checklist Final**

### Correcciones Cr√≠ticas
- [ ] **Eliminar todas las referencias a `token_expiry`**
- [ ] **Corregir `initializeTokens()` - setear token antes de verificar expiraci√≥n**
- [ ] **Simplificar `getAuthToken()` - l√≥gica m√°s clara y directa**

### Verificaci√≥n de Funcionamiento
- [ ] Silent login funciona con `GET /auth/google/silent?email=...`
- [ ] Renovaci√≥n autom√°tica cada 24h con `POST /auth/refresh`
- [ ] Reintento autom√°tico en errores 401
- [ ] Persistencia correcta: `access_token`, `refresh_token`, `user_email`
- [ ] Logout limpia completamente el estado

### Limpieza Final
- [ ] No hay referencias a `token_expiry` en todo el archivo
- [ ] No hay llamadas a endpoints inexistentes
- [ ] Variables de control usan `useRef` correctamente
- [ ] Logs excesivos removidos para producci√≥n

---

## üéØ **Snippet Completo de initializeTokens Corregido**

```javascript
const initializeTokens = () => {
  const savedToken = localStorage.getItem('access_token');
  const savedRefresh = localStorage.getItem('refresh_token');
  
  console.log('üîç Inicializando tokens desde localStorage...');
  console.log('üì¶ Token guardado:', !!savedToken);
  console.log('üì¶ Refresh token guardado:', !!savedRefresh);
  
  if (savedRefresh) {
    setRefreshToken(savedRefresh);
  }

  if (savedToken) {
    // Setear token primero
    setAccessToken(savedToken);
    
    // Verificar expiraci√≥n despu√©s de setear
    if (isAccessTokenExpired()) {
      console.log('‚è∞ Token expirado en localStorage, limpiando...');
      setAccessToken(null);
      localStorage.removeItem('access_token');
      return false;
    }
    
    console.log('üîë Token v√°lido encontrado en localStorage');
    return true;
  } else {
    console.log('‚ùå No hay tokens guardados en localStorage');
  }
  
  return false;
};
```

---

## üéØ **Snippet Completo de getAuthToken Optimizado**

```javascript
const getAuthToken = async () => {
  console.log('üîë getAuthToken llamado - accessToken:', !!accessToken, 'expired:', isAccessTokenExpired());
  
  // 1. Token v√°lido existente
  if (accessToken && !isAccessTokenExpired()) {
    console.log('‚úÖ Usando token existente v√°lido');
    return accessToken;
  }
  
  // 2. Evitar llamadas simult√°neas
  if (tokenRefreshPromiseRef.current) {
    console.log('‚è≥ Esperando llamada de token en progreso...');
    return await tokenRefreshPromiseRef.current;
  }
  
  // 3. Verificar cooldown
  const now = Date.now();
  if (now - lastTokenRefreshRef.current < TOKEN_REFRESH_COOLDOWN) {
    console.log('‚è∞ Cooldown activo, usando token existente si est√° disponible');
    return accessToken || null;
  }
  
  lastTokenRefreshRef.current = now;
  
  tokenRefreshPromiseRef.current = (async () => {
    try {
      // Prioridad 1: Renovar con refresh_token
      if (refreshToken || localStorage.getItem('refresh_token')) {
        console.log('üîÑ Intentando renovar con refresh_token...');
        return await refreshAccessToken();
      }
      
      // Prioridad 2: Obtener token fresco desde /auth/session
      console.log('üîÑ Obteniendo token fresco desde /auth/session...');
      const response = await fetch(`${getBackendUrl()}/auth/session`, {
        credentials: 'include',
        method: 'GET',
        headers: { 'Content-Type': 'application/json' }
      });
      
      if (response.ok) {
        const data = await response.json();
        if (data.access_token) {
          console.log('‚úÖ Token fresco obtenido desde /auth/session');
          setAccessToken(data.access_token);
          localStorage.setItem('access_token', data.access_token);
          return data.access_token;
        }
      }
      
      console.log('‚ö†Ô∏è No se pudo obtener token fresco');
      return null;
    } finally {
      tokenRefreshPromiseRef.current = null;
    }
  })();
  
  return await tokenRefreshPromiseRef.current;
};
```

---

## üö® **Puntos Cr√≠ticos Finales**

1. **NUNCA usar `token_expiry`** - el JWT ya contiene `exp`
2. **Siempre setear el token ANTES de verificar expiraci√≥n**
3. **Mantener l√≥gica simple y clara** en `getAuthToken()`
4. **Priorizar `refresh_token` sobre `/auth/session`**
5. **Usar `useRef` para todas las variables de control**

---

## üìä **Estado Final Esperado**

Con estas 3 correcciones finales, el `authcontext.js` estar√° **100% alineado** con el backend y funcionar√° perfectamente para:

- ‚úÖ **Sesi√≥n de 30 d√≠as** con `refresh_token`
- ‚úÖ **Renovaci√≥n autom√°tica** cada 24h
- ‚úÖ **Silent login** correcto
- ‚úÖ **Reintento autom√°tico** en errores 401
- ‚úÖ **Persistencia correcta** de tokens
- ‚úÖ **Logout completo** y limpio

**¬°Solo faltan estos 3 ajustes menores para completar la implementaci√≥n!** üéâ
